<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body { margin:0; padding:0; background: transparent; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }

    /* Outer wrapper keeps Streamlit-looking rounded border */
    #resizer {
      width: 100%;
      min-height: 260px;
      height: 420px;
      resize: vertical;
      overflow: auto;
      box-sizing: border-box;
      background: transparent;
      border-radius: 14px;
      border: 1px solid rgba(49, 51, 63, 0.2);
    }

    canvas#c{
      display:block;
      width: 100%;
      height: 100%;
      background: var(--canvas-bg, #F0F2F6);
      border-radius: 14px;
      touch-action: none; /* prevent page scroll while drawing */
    }
  </style>
</head>
<body>
  <div id="resizer"><canvas id="c"></canvas></div>

  <script>
  // Streamlit component plumbing
  const RENDER = "streamlit:render";
  const COMPONENT_READY = "streamlit:componentReady";
  const SET_COMPONENT_VALUE = "streamlit:setComponentValue";
  const SET_FRAME_HEIGHT = "streamlit:setFrameHeight";

  function sendMessageToStreamlitClient(type, data) {
    const outData = Object.assign({ isStreamlitMessage: true, type: type }, data);
    window.parent.postMessage(outData, "*");
  }
  function setFrameHeight(height) {
    sendMessageToStreamlitClient(SET_FRAME_HEIGHT, { height: height });
  }
  function sendDataToPython(data) {
    sendMessageToStreamlitClient(SET_COMPONENT_VALUE, { value: data, dataType: "json" });
  }
  function initComponent() {
    sendMessageToStreamlitClient(COMPONENT_READY, { apiVersion: 1 });
  }

  const resizer = document.getElementById("resizer");
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { willReadFrequently: false });

  let args = {
    stroke_width: 2,
    stroke_color: "#000000",
    background_color: "#F0F2F6",
    pen_only: false,
    tool: "pen",
    command: null,
    command_nonce: 0,
    initial_data_url: null,
  };

  let drawing = false;
  let lastX = 0;
  let lastY = 0;
  let isEmpty = true;

  // Undo history: store data URLs after each stroke end
  let history = [];
  let lastCommandNonce = -1;

  function currentCssSize() {
    return {
      w: Math.max(1, resizer.clientWidth || 600),
      h: Math.max(1, resizer.clientHeight || 420),
    };
  }

  function setBg() {
    const bg = args.background_color || "#F0F2F6";
    canvas.style.setProperty("--canvas-bg", bg);
    ctx.fillStyle = bg;
  }

  function resizeCanvasPreserve() {
    const { w, h } = currentCssSize();

    // preserve current image BEFORE resize (CSS pixel space)
    const prevUrl = (!isEmpty) ? canvas.toDataURL("image/png") : null;

    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    setBg();
    ctx.fillRect(0, 0, w, h);

    if (prevUrl) {
      const img = new Image();
      img.onload = () => {
        ctx.drawImage(img, 0, 0, w, h);
      };
      img.src = prevUrl;
    }

    setFrameHeight(h + 6);
  }

  function snapshotToHistory() {
    const url = canvas.toDataURL("image/png");
    history.push(url);
    if (history.length > 30) history.shift();
  }

  function emitValue() {
    const url = canvas.toDataURL("image/png");
    sendDataToPython({ data_url: url, is_empty: isEmpty });
  }

  function allowedPointer(e) {
    if (args.pen_only) return e.pointerType === "pen";
    return (e.pointerType === "pen" || e.pointerType === "touch" || e.pointerType === "mouse");
  }

  function isHover(e) {
    return (e.pressure === 0 && e.buttons === 0);
  }

  function pointerDown(e) {
    if (!allowedPointer(e)) return;
    if (isHover(e)) return;
    drawing = true;
    const rect = canvas.getBoundingClientRect();
    lastX = e.clientX - rect.left;
    lastY = e.clientY - rect.top;
    try { canvas.setPointerCapture(e.pointerId); } catch (_) {}
  }

  function pointerMove(e) {
    if (!drawing) return;
    if (!allowedPointer(e)) return;
    if (isHover(e)) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.lineWidth = args.stroke_width;

    if (args.tool === "eraser") {
      ctx.strokeStyle = args.background_color || "#F0F2F6";
    } else {
      ctx.strokeStyle = args.stroke_color || "#000000";
    }

    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(x, y);
    ctx.stroke();

    lastX = x;
    lastY = y;

    isEmpty = false;
  }

  function pointerUp(e) {
    if (!drawing) return;
    drawing = false;
    snapshotToHistory();
    emitValue();
  }

  canvas.addEventListener("pointerdown", pointerDown);
  canvas.addEventListener("pointermove", pointerMove);
  canvas.addEventListener("pointerup", pointerUp);
  canvas.addEventListener("pointercancel", pointerUp);

  function drawImageDataUrl(dataUrl) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        const { w, h } = currentCssSize();
        setBg();
        ctx.fillRect(0, 0, w, h);
        ctx.drawImage(img, 0, 0, w, h);
        resolve(true);
      };
      img.onerror = () => resolve(false);
      img.src = dataUrl;
    });
  }

  async function applyCommand(cmd) {
    if (!cmd) return;
    const { w, h } = currentCssSize();

    if (cmd === "clear") {
      setBg();
      ctx.fillRect(0, 0, w, h);
      isEmpty = true;
      history = [];
      emitValue();
      return;
    }

    if (cmd === "undo") {
      if (history.length === 0) {
        setBg();
        ctx.fillRect(0, 0, w, h);
        isEmpty = true;
        emitValue();
        return;
      }
      history.pop();
      const prev = history.length ? history[history.length - 1] : null;
      if (!prev) {
        setBg();
        ctx.fillRect(0, 0, w, h);
        isEmpty = true;
        emitValue();
        return;
      }
      const ok = await drawImageDataUrl(prev);
      isEmpty = !ok;
      emitValue();
      return;
    }
  }

  async function onDataFromPython(event) {
    if (event.data.type !== RENDER) return;
    const a = event.data.args || {};

    args.stroke_width = a.stroke_width ?? args.stroke_width;
    args.stroke_color = a.stroke_color ?? args.stroke_color;
    args.background_color = a.background_color ?? args.background_color;
    args.pen_only = a.pen_only ?? args.pen_only;
    args.tool = a.tool ?? args.tool;

    // keep size in sync (preserve drawing)
    resizeCanvasPreserve();

    // Optional restore (e.g., after Streamlit reruns when sidebar toggles)
    if (a.initial_data_url && typeof a.initial_data_url === "string") {
      if (isEmpty) {
        const ok = await drawImageDataUrl(a.initial_data_url);
        if (ok) {
          isEmpty = false;
          snapshotToHistory();
          emitValue();
        }
      }
    }

    const nonce = Number(a.command_nonce ?? 0);
    if (nonce !== lastCommandNonce) {
      lastCommandNonce = nonce;
      const cmd = a.command ?? null;
      await applyCommand(cmd);
    }
  }

  window.addEventListener("message", onDataFromPython);

  // Resize observer to keep iframe height correct when user drags resizer
  const ro = new ResizeObserver(() => {
    resizeCanvasPreserve();
  });
  ro.observe(resizer);

  initComponent();
  window.addEventListener("load", () => {
    setTimeout(() => resizeCanvasPreserve(), 0);
  });
  </script>
</body>
</html>
